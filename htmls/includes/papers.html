{% h2 '<i class="fa fa-book"></i>' "Publications" "Publications" %}

{% def author(name,orcidn) name&nbsp;<a class="link external" href="https://orcid.org/orcidn"><i class="fab fa-orcid"></i></a>%}
{% def aut_dlesbre {% author "Dorian Lesbre" "0000-0002-4328-6753"%} %}
{% def aut_mlemerre {% author "Matthieu Lemerre" "0000-0002-1081-0467" %} %}

<div class="content filelist">
	<div>
    <span class="title">Compiling with Abstract Interpretation</span>
    &dash;
    <a href="https://dx.doi.org/10.1145/3656392" class="link external">10.1145/3656392</a>
  </div>
	<div class="type">{% aut_dlesbre %} {% lang et and %} {% aut_mlemerre %}</div>
	<div class="date">PLDI 2024</div>
  <div>
    <img src="imgs/artifacts-available.png" alt="Artifact available" width=35 height=35>
    <img src="imgs/artifacts-evaluated-reusable.png" alt="Artifact evaluated reusable" width=35 height=35>
  </div>
	<a class="collapsible folded">{% lang Resumé Abstract %}</a>
  <div class="content abstract folded">
    Rewriting and static analyses are mutually beneficial techniques: program transformations change the inten-
    sional aspects of the program, and can thus improve analysis precision, while some efficient transformations
    are enabled by specific knowledge of some program invariants. Despite the strong interaction between these
    techniques, they are usually considered distinct. In this paper, we demonstrate that we can turn abstract
    interpreters into compilers, using a simple free algebra over the standard signature of abstract domains.
    Functor domains correspond to compiler passes, for which soundness is translated to a proof of forward
    simulation, and completeness to backward simulation. We achieve translation to SSA using an abstract do-
    main with a non-standard SSA signature. Incorporating such an SSA translation to an abstract interpreter
    improves its precision; in particular we show that an SSA-based non-relational domain is always more precise
    than a standard non-relational domain for similar time and memory complexity. Moreover, such a domain
    allows recovering from precision losses that occur when analyzing low-level machine code instead of source
    code. These results help implement analyses or compilation passes where symbolic and semantic methods
    simultaneously refine each other, and improves precision when compared to doing the passes in sequence.
  </div>
    <div class="llinks paper">
      <a class="linkbutton" href="https://codex.top/papers/2024-pldi-compiling-with-abstract-interpretation.html">
        <i class="fas fa-lightbulb"></i>
        <b>{% lang "Aperçu" "In a nutshell" %}</b>
      </a>
      <a class="linkbutton" href="files/publications/2024-pldi-compiling-with-abstract-interpretation.pdf">
        <i class="fas fa-file-pdf"></i>
        <b>PDF</b>
      </a>
      <a class="linkbutton" href="files/publications/2024-pldi-compiling-with-abstract-interpretation-with-appendices.pdf">
        <i class="fas fa-file-pdf"></i>
        <b>{% lang "PDF avec annexes" "PDF with appendix" %}</b>
      </a>
      <a class="linkbutton" href="files/publications/2024-pldi-compiling-with-abstract-interpretation.bib">
        <i class="fas fa-quote-left"></i>
        <b>Bibtex</b>
      </a>
      <a class="linkbutton" href="https://doi.org/10.5281/zenodo.10895582">
        <i class="fas fa-laptop-code"></i>
        <b>{% lang "Artefact" "Artifact" %}</b>
      </a>
      <a class="linkbutton" href="https://www.youtube.com/watch?v=2Btkn9AvM8o">
        <i class="fas fa-play-circle"></i>
        <b>{% lang "Présentation" "Talk" %} (18 min)</b>
      </a>
      <a class="linkbutton" href="files/publications/2024-pldi-compiling-with-abstract-interpretation-slides.pdf">
        <i class="fas fa-file-powerpoint"></i>
        <b>{% lang "Diapositives" "Slides" %}</b>
      </a>
    </div>
</div>

<div class="content filelist" style="margin-top: 30px;">
  <div>
    <span class="title">Labeled Union-Find for Constraint Factorization</span>
    &dash;
    {% lang "Papier court" "Short paper" %}
  </div>
  <div class="type">{% aut_mlemerre %} {% lang et and %} {% aut_dlesbre %}</div>
  <div class="date">NSAD 2024</div>
  <a class="collapsible folded">{% lang Resumé Abstract %}</a>
    <div class="content abstract folded">
      In this work-in-progress paper, we present labeled union-find,
      an extension of the union-find data structure where
      edges are annotated with labels that form a group algebraic
      structure. This structure allows to very efficiently represent
      the transitive closure of many useful binary relations, such as
      two-variables per equality (TVPE) constraints of the form
      <code>y = ax+b</code>. We characterize the properties of labeled union-find
      when used to represent binary relations between variables.
      More specifically, we study the use of this domain in a static
      analysis; either to represent binary relations, or as a reduced
      product with non-relational abstract domains with constraint
      propagation; as well as the design of efficient algorithms for
      the join of labeled union-find structures. We believe that this
      structure could be used as a low-cost relational domain or
      decision procedure, and that it could make other relational
      domains more efficient by removing the need to track some
      variables.
    </div>

    <div class="llinks paper">
      <a class="linkbutton" href="files/publications/2024-nsad-labeled-union-find.pdf">
        <i class="fas fa-file-pdf"></i>
        <b>PDF</b>
      </a>
      <a class="linkbutton" href="files/publications/2024-nsad-labeled-union-find.bib">
        <i class="fas fa-quote-left"></i>
        <b>Bibtex</b>
      </a>
      <a class="linkbutton" href="https://www.youtube.com/watch?v=AkIzUufinWY&amp;t=26532">
        <i class="fas fa-play-circle"></i>
        <b>{% lang "Présentation" "Talk" %} (28 min)</b>
      </a>
    </div>
</div>
